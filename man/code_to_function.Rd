% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/code_to_function.R
\name{code_to_function}
\alias{code_to_function}
\title{Declare existing scripts to be run
\lifecycle{experimental}}
\usage{
code_to_function(path, ...)
}
\arguments{
\item{path}{Character vector, path to script.}
}
\value{
An expression to be input into the drake plan
}
\description{
\code{source_script()} parses individual script files
to be added into the drake workflow
}
\section{Keywords}{

\code{\link[=drake_plan]{drake_plan()}} understands special keyword functions for your commands.
With the exception of \code{\link[=target]{target()}}, each one is a proper function
with its own help file.
\itemize{
\item \code{\link[=target]{target()}}: give the target more than just a command.
Using \code{\link[=target]{target()}}, you can apply a transformation
(examples: \url{https://ropenscilabs.github.io/drake-manual/plans.html#large-plans}), # nolint
supply a trigger (\url{https://ropenscilabs.github.io/drake-manual/triggers.html}), # nolint
or set any number of custom columns.
\item \code{\link[=map]{map()}}: create multiple targets. Called inside \code{\link[=target]{target()}}.
\item \code{\link[=split]{split()}}: create a target for each subset of data.
Called inside \code{\link[=target]{target()}}.
\item \code{\link[=cross]{cross()}}: create a target for each combination of values.
Called inside \code{\link[=target]{target()}}.
\item \code{\link[=combine]{combine()}}: aggregate groups of targets into other targets.
Called inside \code{\link[=target]{target()}}.
\item \code{\link[=file_in]{file_in()}}: declare an input file dependency.
\item \code{\link[=file_out]{file_out()}}: declare an output file to be produced
when the target is built.
\item \code{\link[=knitr_in]{knitr_in()}}: declare a \code{knitr} file dependency such as an
R Markdown (\code{*.Rmd}) or R LaTeX (\code{*.Rnw}) file.
\item \code{\link[=ignore]{ignore()}}: force \code{drake} to entirely ignore a piece of code:
do not track it for changes and do not analyze it for dependencies.
\item \code{\link[=no_deps]{no_deps()}}: tell \code{drake} to not track the dependencies
of a piece of code. \code{drake} still tracks the code itself for changes.
\item \code{\link[=drake_envir]{drake_envir()}}: get the environment where drake builds targets.
Intended for advanced custom memory management.
}
}

\examples{
\dontrun{
isolate_example("contain side effects", {
# The `code_to_function()` function
# just parses the script to make it available for drake to
# analyze for dependencies.
# The main purpose is to allow pre-exising workflows to
# incorporate drake into the workflow seamlessly

script1 <- tempfile()
script2 <- tempfile()
script3 <- tempfile()
script4 <- tempfile()
writeLines(c("data <- mtcars", "munge(data)"), script1)
writeLines("analyze(munged)", script2)
writeLines("summarize_results(analysis)", script3)
writeLines("plot_results(analysis)", script4)

plan <- drake_plan(
  munged   = !!source_script(script1),
  analysis = !!source_script(script2),
  summary  = !!source_script(script3),
  plot     = !!source_script(script4),
 )

plan
# drake knows "\\"mtcars.csv\\"" is the first target
# and a dependency of `contents`. See for yourself:

make(plan)
file.exists("mtcars.csv")

# See the connections that the sourced scripts create:
config <- drake_config(plan)
if (requireNamespace("visNetwork", quietly = TRUE)) {
  vis_drake_graph(config)
}
})
}
}
\seealso{
\code{\link[=file_in]{file_in()}}, \code{\link[=file_out]{file_out()}}, \code{\link[=knitr_in]{knitr_in()}}, \code{\link[=ignore]{ignore()}}, \code{\link[=no_deps]{no_deps()}}
}
